package org.briansimulator.briandroid.Simulations;

import android.content.Context;
import android.os.AsyncTask;
import android.util.Log;
import android.widget.TextView;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;

import dalvik.system.DexClassLoader;

/**
 * Created by Achilleas Koutsou on 31/07/13.
 *
 * The SimRunner class handles running of standalone simulations generated by
 * the Brian2 codegen module.
 *
 */
public class SimRunner extends AsyncTask<Void, String, Void> {
    final static String LOGID = "org.briansimulator.briandroid.Simulations.SimRunner";
    protected TextView progressText;
    Class simulationClass;
    Object simulation;
    String simulationDescription;
    Context appContext;

    // File I/O code to copy the secondary dex file from asset resource to internal storage.
    private boolean prepareDex(String dexLocation, File dexInternalStoragePath) {
        FileInputStream fis = null;
        OutputStream dexWriter = null;
        int bufSize = 128*1024;
        try {
            fis = new FileInputStream(new File(dexLocation));
            dexWriter = new BufferedOutputStream(new FileOutputStream(dexInternalStoragePath));
            byte[] buf = new byte[bufSize];
            int len;
            while((len = fis.read(buf, 0, bufSize)) > 0) {
                dexWriter.write(buf, 0, len);
            }
            dexWriter.close();
            fis.close();
            return true;
        } catch (IOException e) {
            if (dexWriter != null) {
                try {
                    dexWriter.close();
                } catch (IOException ioe) {
                    ioe.printStackTrace();
                }
            }
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException ioe) {
                    ioe.printStackTrace();
                }
            }
            e.printStackTrace();
            return false;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    public SimRunner(Context context, String classLocationStr) {
        // TODO: check file type here: perhaps unnecessary since the class loading will fail if it's not a proper class
        Log.d(LOGID, "Copying dex file to internal storage.");
        // From http://android-developers.blogspot.com/2011/07/custom-class-loading-in-dalvik.html
        // Before the secondary dex file can be processed by the DexClassLoader,
        // it has to be first copied from asset resource to a storage location.
        File originalDex = new File(classLocationStr);
        String dexName = originalDex.getName();
        this.appContext = context;
        final File dexInternalStoragePath = new File(appContext.getDir("dex", Context.MODE_PRIVATE),
                                                        dexName);
        if (!dexInternalStoragePath.exists()) {
            // TODO: start loading spinner

            if (!prepareDex(classLocationStr, dexInternalStoragePath)) {
                Log.e(LOGID, "Caching of dex file failed!");
                // TODO: Error popup -- throw exception???
            }
        }
        Log.d(LOGID, "Loading class " + dexInternalStoragePath.toString());
        // Internal storage where the DexClassLoader writes the optimized dex file to.
        final File optimisedDexOutputPath = appContext.getDir("outdex", Context.MODE_PRIVATE);

        // Initialize the class loader with the secondary dex file.
        DexClassLoader cl = new DexClassLoader(dexInternalStoragePath.getAbsolutePath(),
                optimisedDexOutputPath.getAbsolutePath(),
                null,
                appContext.getClassLoader());
        Class loadedClass = null;

        Object classInstance = null;
        try {
            // Load the library class from the class loader.
            loadedClass = cl.loadClass(dexName.replace(".dex", ""));
            Method[] classMethods = loadedClass.getDeclaredMethods();
            Log.d(LOGID, "Methods:");
            for (Method meth : classMethods) {
                Log.d(LOGID, meth.getName());
            }
            Field[] classFields = loadedClass.getDeclaredFields();
            Log.d(LOGID, "Fields:");
            for (Field f : classFields) {
                Log.d(LOGID, f.getName());
            }
            classInstance = loadedClass.newInstance();
            simulationDescription = (String)loadedClass.getDeclaredMethod("getDescription").invoke(classInstance, null);


            // Cast the return object to the library interface so that the
            // caller can directly invoke methods in the interface.
            // Alternatively, the caller can invoke methods through reflection,
            // which is more verbose and slow.
            //
            // TODO: Adapt the existing Simulation.class for this purpose
            //
            // LibraryInterface lib = (LibraryInterface) libProviderClass.newInstance();

        } catch (Exception e) {
            // TODO: Handle exceptions
            e.printStackTrace();
        }
        simulationClass = loadedClass;
        simulation = classInstance;
    }

    protected Void doInBackground(Void... _) {
        Method simSetup, simRun;
        try {
            simSetup = simulationClass.getDeclaredMethod("setup", (Class)null);
        } catch (NoSuchMethodException nsme) {
            Log.d(LOGID, "Class "+simulationClass.getName()+" does not declare setup() method.");
            nsme.printStackTrace();
            return null;
        }
        try {
            simRun = simulationClass.getDeclaredMethod("run", (Class)null);
        } catch (NoSuchMethodException nsme) {
            Log.d(LOGID, "Class "+simulationClass.getName()+" does not declare run() method.");
            nsme.printStackTrace();
            return null;
        }
        try {
            simSetup.invoke(simulationClass, (Object)null);
            simRun.invoke(simulationClass, (Object)null);
        } catch (Exception e) {  // TODO: Catch exceptions properly
            Log.d(LOGID, "Error running simulation "+simulationClass.getName()+". Exception trace follows.");
            e.printStackTrace();
        }
        return null;
    }

    public String getDescription() {
        return simulationDescription;
    }

    public void setProgressView(TextView tv) {
        progressText = tv;
    }

    @Override
    protected void onProgressUpdate(String... progress) {
        progressText.setText(progress[0]);
    }
}
