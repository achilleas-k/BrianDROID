import java.io.File;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;


/** Created by achilleas on 2013-08-09
 *
 * Template for simulations generated by Brian's codegen module for use
 * in BrianDROID.
 *
 * Requirements:
 *      TODO: List required methods and fields
 *
 */
public class HHGen {

    // these vars should be available for almost all simulations
    final static Random rng = new Random();
    final float _duration = 0.5f;
    final float dt = 0.0001f;
    float t;
    float progress;
    private String simulationStatus;
    private final String DESCRIPTION = "%%DESCRIPTION%%";

    public float getTime() {
        return t;
    }

    public float getDuration() {
        return _duration;
    }

    public float getProgress() {
        return progress;
    }


    public String getStatusText() {
        return simulationStatus;
    }

    public String getDescription() {
        return DESCRIPTION;
    }

    protected void setStatusText(String statusText) {
        simulationStatus = statusText;
    }

    protected void appendStatusText(String extraText) {
        simulationStatus += extraText;
    }

    //*********** PUBLIC VARS **********
    double[] _array_gp_I;
    double[] _array_gp_v;
    double[] _array_gp_h;
    double[] _array_gp_n;
    double[] _array_gp_m;
    boolean[] _array_gp_not_refractory;
    //*********** SETUP METHOD *********
    public void setup() {
        _array_gp_I = new double [100];
        _array_gp_v = new double [100];
        _array_gp_h = new double [100];
        _array_gp_n = new double [100];
        _array_gp_m = new double [100];
        _array_gp_not_refractory = new boolean [100];
    }
    //*********** MAIN LOOP *************
    public void run() {
        for (t=0; t<_duration; t+=dt) {
            final int _num_neurons = 100;
            final double ms = 0.001;
            final int _numm = 100;
            final double Cm = 2e-10;
            final double El = -0.065;
            final double g_na = 2e-05;
            final double VT = -0.063;
            final double mV = 0.001;
            final double ENa = 0.05;
            final double EK = -0.09;
            final int _numI = 100;
            final double g_kd = 6e-06;
            final double gl = 1e-08;
            final int _numh = 100;
            final int _numn = 100;
            final int _numv = 100;
            final int _numnot_refractory = 100;
            // USE_SPECIFIERS { _num_neurons }

            ////// SUPPORT CODE ///
            //


            for(int _neuron_idx=0; _neuron_idx<_num_neurons; _neuron_idx++)
            {
                final int _vectorisation_idx = _neuron_idx;
                final double I = _array_gp_I[_neuron_idx];
                double h = _array_gp_h[_neuron_idx];
                double m = _array_gp_m[_neuron_idx];
                double n = _array_gp_n[_neuron_idx];
                double v = _array_gp_v[_neuron_idx];
                boolean not_refractory = _array_gp_not_refractory[_neuron_idx];
                not_refractory = ((not_refractory) || (!(v > -40 * mV)));
                final double _BA_h = -0.32913969447672 * (2980.95798704173 * Math.exp(0.2 * VT / mV) + 1.0 * Math.exp(0.2 * v / mV)) * Math.exp(0.055556 * v / mV) * Math.exp((0.055556 * VT - 0.055556 * v) / mV) / ((981.151601102854 * Math.exp(0.2 * VT / mV) + 0.32913969447672 * Math.exp(0.2 * v / mV)) * Math.exp(0.055556 * VT / mV) + 4.0 * Math.exp(0.255556 * v / mV));
                final double _h = -(_BA_h) + (_BA_h + h) * Math.exp(-(dt) * ((981.151601102854 * Math.exp(0.2 * VT / mV) + 0.32913969447672 * Math.exp(0.2 * v / mV)) * Math.exp(0.055556 * VT / mV) + 4.0 * Math.exp(0.255556 * v / mV)) * Math.exp(-0.055556 * v / mV) / (ms * (2980.95798704173 * Math.exp(0.2 * VT / mV) + 1.0 * Math.exp(0.2 * v / mV))));
                final double _BA_v = -(EK * g_kd * Math.pow(n, 4.0) + ENa * g_na * h * Math.pow(m, 3.0) + El * gl + I) / (g_kd * Math.pow(n, 4.0) + g_na * h * Math.pow(m, 3.0) + gl);
                final double _v = -(_BA_v) + (_BA_v + v) * Math.exp(-(dt) * (g_kd * Math.pow(n, 4.0) + g_na * h * Math.pow(m, 3.0) + gl) / Cm);
                final double _BA_m = (-1.0 * Math.exp(0.2 * VT / mV) + 0.000335462627902512 * Math.exp(0.2 * v / mV)) * (0.32 * VT + 4.16 * mV - 0.32 * v) * Math.exp(0.25 * v / mV) / ((-1.0 * Math.exp(0.2 * VT / mV) + 0.000335462627902512 * Math.exp(0.2 * v / mV)) * (-0.32 * VT - 4.16 * mV + 0.32 * v) * Math.exp(0.25 * v / mV) + (25.7903399171931 * Math.exp(0.25 * VT / mV) - 1.0 * Math.exp(0.25 * v / mV)) * (0.28 * VT + 11.2 * mV - 0.28 * v) * Math.exp(0.2 * VT / mV));
                final double _m = -(_BA_m) + (_BA_m + m) * Math.exp(dt * ((-1.0 * Math.exp(0.2 * VT / mV) + 0.000335462627902512 * Math.exp(0.2 * v / mV)) * (-0.32 * VT - 4.16 * mV + 0.32 * v) * Math.exp(0.25 * v / mV) + (25.7903399171931 * Math.exp(0.25 * VT / mV) - 1.0 * Math.exp(0.25 * v / mV)) * (0.28 * VT + 11.2 * mV - 0.28 * v) * Math.exp(0.2 * VT / mV)) / (mV * ms * (-1.0 * Math.exp(0.2 * VT / mV) + 0.000335462627902512 * Math.exp(0.2 * v / mV)) * (25.7903399171931 * Math.exp(0.25 * VT / mV) - 1.0 * Math.exp(0.25 * v / mV))));
                final double _BA_n = (0.032 * VT + 0.48 * mV - 0.032 * v) * Math.exp(0.225 * v / mV) / (mV * (-12.8951699585965 * Math.exp(0.2 * VT / mV) + 0.642012708343871 * Math.exp(0.2 * v / mV)) * Math.exp(0.025 * VT / mV) + (-0.032 * VT - 0.48 * mV + 0.032 * v) * Math.exp(0.225 * v / mV));
                final double _n = -(_BA_n) + (_BA_n + n) * Math.exp(dt * (mV * (-12.8951699585965 * Math.exp(0.2 * VT / mV) + 0.642012708343871 * Math.exp(0.2 * v / mV)) * Math.exp(0.025 * VT / mV) + (-0.032 * VT - 0.48 * mV + 0.032 * v) * Math.exp(0.225 * v / mV)) * Math.exp(-0.025 * v / mV) / (mV * ms * (20.0855369231877 * Math.exp(0.2 * VT / mV) - 1.0 * Math.exp(0.2 * v / mV))));
                h = _h;
                v = _v;
                m = _m;
                n = _n;
                _array_gp_h[_neuron_idx] = h;
                _array_gp_v[_neuron_idx] = v;
                _array_gp_m[_neuron_idx] = m;
                _array_gp_not_refractory[_neuron_idx] = not_refractory;
                _array_gp_n[_neuron_idx] = n;
            }

        }}
}


